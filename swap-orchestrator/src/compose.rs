use std::{
    fmt::{Display, Write},
    path::PathBuf,
    sync::Arc,
};

use url::Url;

use crate::writer::IndentedWriter;

/// Trait implemented by every part of a [`ComposeConfig`]
/// which writes that part of the config to an output.
trait WriteConfig {
    fn write_to(&self, writer: &mut IndentedWriter);
}

/// A Docker Compose config that can be written to a `docker-compose.yml` file.
///
/// Create with [`ComposeConfig::new`] and add volumes and services
/// using [`ComposeConfig::add_volume`] and [`ComposeConfig::add_service`].
#[derive(Debug, Clone)]
pub struct ComposeConfig {
    services: Vec<Arc<Service>>,
    volumes: Vec<Arc<Volume>>,
}

/// A service which may be added to a [`ComposeConfig`].
#[derive(Debug, Clone)]
pub struct Service {
    name: String,
    depends_on: Vec<Arc<Service>>,
    image_source: ImageSource,
    exposed_ports: Vec<u16>,
    volumes: Vec<Mount>,
    restart_type: RestartType,
    entrypoint: Option<String>,
    command: Option<Command>,
    stdin_open: Option<bool>,
    tty: Option<bool>,
    enabled: bool,
}

/// Specify how to mount a specific path or volume of the host system to the container.
#[derive(Debug, Clone)]
pub struct Mount {
    host_path: VolumeOrPath,
    container_path: PathBuf,
}

/// Host side of a mount expression.
/// Either a volume or a path to some directory/file.
#[derive(Debug, Clone)]
enum VolumeOrPath {
    Volume(Arc<Volume>),
    Path(PathBuf),
}

/// A volume that's part of a Docker Compose config.
/// Can only be obtained as `Arc<Volume>` via [`ComposeConfig::add_volume`].
#[derive(Debug, Clone)]
pub struct Volume {
    name: String,
}

/// Configure how to obtain the container image.
#[derive(Debug, Clone)]
pub enum ImageSource {
    BuildFromSource {
        /// Url to the git repo (may contain commit hash).
        git_url: Url,
        /// Relative path to Dockerfile from repo root.
        dockerfile_path: String,
    },
    PullFromRegistry {
        /// Standard docker registry url.
        image_url: String,
    },
}

#[derive(Debug, Clone)]
pub struct Command {
    flags: Vec<Flag>,
}

#[derive(Debug, Clone)]
pub struct Flag(String);

/// Configure when to restart the service.
#[derive(Debug, Clone, Copy)]
pub enum RestartType {
    UnlessStopped,
}

impl ComposeConfig {
    /// Add a volume to the config.
    /// Returns a handle which can be used to reference this volume later.
    pub fn add_volume(&mut self, name: impl Into<String>) -> Arc<Volume> {
        let volume = Arc::new(Volume::new(name.into()));
        self.volumes.push(volume.clone());

        volume
    }

    /// Add a service to the config.
    /// Returns a handle which can be used to reference this service later.
    ///
    /// Create services using [`Service::new`].
    pub fn add_service(&mut self, service: Service) -> Arc<Service> {
        let service = Arc::new(service);
        self.services.push(service.clone());

        service
    }

    /// Finish this config and make it into a docker-compose.yml compatible string.
    pub fn build(self) -> String {
        let mut writer = IndentedWriter::new();
        self.write_to(&mut writer);

        let result = writer.finish();

        let _: compose_spec::Compose =
            serde_yaml::from_str(&result).expect("valid docker-compose.yml syntax");

        result
    }
}

impl Default for ComposeConfig {
    fn default() -> ComposeConfig {
        ComposeConfig {
            services: Vec::new(),
            volumes: Vec::new(),
        }
    }
}

impl WriteConfig for ComposeConfig {
    fn write_to(&self, writer: &mut IndentedWriter) {
        writeln!(writer, "# This file is automatically @generated by the eigenwallet orchestrator.\n# It is not intended for manual editing.").unwrap();
        writeln!(writer, "name: eigenwallet-maker").unwrap();
        writeln!(writer, "services:").unwrap();

        writer.indented(|writer| {
            for service in &self.services {
                service.write_to(writer);
            }
        });

        writeln!(writer, "volumes:").unwrap();

        writer.indented(|writer| {
            for volume in &self.volumes {
                writeln!(writer, "{}:", volume.name()).unwrap();
            }
        });
    }
}

impl Service {
    /// Create a new Docker Compose service. Use the `with_*` methods to configure
    /// it, before adding it to the config with [`ComposeConfig::add_service`].
    pub fn new(name: impl Into<String>, image_source: ImageSource) -> Service {
        let name: String = name.into();

        Service {
            name,
            depends_on: Vec::new(),
            exposed_ports: Vec::new(),
            image_source,
            command: None,
            restart_type: RestartType::UnlessStopped,
            volumes: Vec::new(),
            entrypoint: None,
            stdin_open: None,
            tty: None,
            enabled: true,
        }
    }

    /// Expose a specific port of this service.
    /// Can be called multiple times.
    ///
    /// Expands to the following:
    /// ```docker ignore
    ///     expose:
    ///       - 0.0.0.0:{port}:{port}
    /// ```
    ///
    /// TODO: support mapping to other port
    /// TODO: support exposing only on localhost
    pub fn with_exposed_port(mut self, port: u16) -> Service {
        self.exposed_ports.push(port);

        self
    }

    /// Add a volume or other path to this service's container by
    /// mounting it from the host system.
    pub fn with_mount(mut self, mount: Mount) -> Service {
        self.volumes.push(mount);

        self
    }

    /// Add a dependency on another service. The other service will be listed
    /// in the `depends_on` section of this service.
    pub fn with_dependency(mut self, service: Arc<Service>) -> Service {
        self.depends_on.push(service);

        self
    }

    /// Set this service's `command` field. Further calls will override earlier values.
    pub fn with_command(mut self, command: Command) -> Service {
        self.command = Some(command);

        self
    }

    /// Set `stdin_open` to an explicit value.
    ///
    /// Todo: find out default value + actual meaning.
    pub fn with_stdin_open(mut self, stdin_open: bool) -> Service {
        self.stdin_open = Some(stdin_open);

        self
    }

    /// Set `tty` to an explicit value.
    ///
    /// Todo: find out default value + actual meaning.
    pub fn with_tty(mut self, tty: bool) -> Service {
        self.tty = Some(tty);

        self
    }

    /// Set whether this service should be enabled.
    ///
    /// Is represented in the `docker-compose.yml` as
    /// `profiles: ['disabled']`, if set to false.
    pub fn with_enabled(mut self, enabled: bool) -> Service {
        self.enabled = enabled;

        self
    }

    /// Get the name of the service.
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Check whether the service is currently enabled.
    pub fn is_enabled(&self) -> bool {
        self.enabled
    }
}

impl WriteConfig for Service {
    fn write_to(&self, writer: &mut IndentedWriter) {
        // {service_name}:
        writeln!(writer, "{}:", &self.name).unwrap();

        writer.indented(|writer| {
            // container_name
            writeln!(writer, "container_name: {}", &self.name).unwrap();
            // image/build
            self.image_source.write_to(writer);
            // restart
            self.restart_type.write_to(writer);

            // depends_on (if specified)
            if !self.depends_on.is_empty() {
                writeln!(writer, "depends_on:").unwrap();
                // write every individual dependency service
                writer.indented(|writer| {
                    for dependency in &self.depends_on {
                        writeln!(writer, "- {}", &dependency.name).unwrap();
                    }
                });
            }

            // stdin_open (if specified)
            if let Some(stdin_open) = self.stdin_open {
                writeln!(writer, "stdin_open: {stdin_open}").unwrap();
            }
            // tty (if specified)
            if let Some(tty) = self.tty {
                writeln!(writer, "tty: {tty}").unwrap();
            }

            // entrypoint (if specified)
            if let Some(entrypoint) = &self.entrypoint {
                writeln!(writer, "entrypoint: \"{}\"", entrypoint).unwrap();
            }

            // command (if specified)
            if let Some(command) = &self.command {
                command.write_to(writer);
            }

            // volumes (if specified)
            if !self.volumes.is_empty() {
                writeln!(writer, "volumes:").unwrap();
                // write every individual mount
                writer.indented(|writer| {
                    for mount in &self.volumes {
                        mount.write_to(writer);
                    }
                });
            }

            // exposed ports (if specified)
            if !self.exposed_ports.is_empty() {
                writeln!(writer, "expose:").unwrap();

                writer.indented(|writer| {
                    for port in &self.exposed_ports {
                        writeln!(writer, "- {port}").unwrap();
                    }
                })
            }

            // Add the "disabled" profile if the service was disabled
            // -> service isn't started unless specifically specified
            if !self.enabled {
                writeln!(writer, "profiles: [\"disabled\"]").unwrap();
            }
        });
    }
}

impl ImageSource {
    pub fn from_registry(image_url: impl Into<String>) -> ImageSource {
        ImageSource::PullFromRegistry {
            image_url: image_url.into(),
        }
    }

    pub fn from_source(git_url: Url, dockerfile_path: impl Into<String>) -> ImageSource {
        ImageSource::BuildFromSource {
            git_url,
            dockerfile_path: dockerfile_path.into(),
        }
    }
}

impl WriteConfig for ImageSource {
    fn write_to(&self, writer: &mut IndentedWriter) {
        match self {
            ImageSource::BuildFromSource {
                git_url,
                dockerfile_path,
            } => {
                writeln!(
                    writer,
                    "build: {{ context: \"{git_url}\", dockerfile: \"{dockerfile_path}\" }}"
                )
                .unwrap();
            }
            ImageSource::PullFromRegistry { image_url } => {
                writeln!(writer, "image: \"{image_url}\"").unwrap()
            }
        }
    }
}

impl Mount {
    /// Mount a specific path from the host system to a specific path on the container system.
    /// `container_path` must be an absolute path.
    pub fn path(host_path: impl Into<PathBuf>, container_path: impl Into<PathBuf>) -> Mount {
        Mount {
            host_path: VolumeOrPath::Path(host_path.into()),
            container_path: container_path.into(),
        }
    }

    /// Mount a volume as a root dir in the container.
    /// For example, the volume `foo` will be mounted to `/foo/` in
    /// the container.
    pub fn volume(volume: &Arc<Volume>) -> Mount {
        Mount {
            host_path: VolumeOrPath::Volume(volume.clone()),
            container_path: volume.as_root_dir(),
        }
    }

    /// Mount a volume to a specific path in the container system.
    /// `container_path` must be an absolute path.
    pub fn volume_to(volume: &Arc<Volume>, container_path: impl Into<PathBuf>) -> Mount {
        Mount {
            host_path: VolumeOrPath::Volume(volume.clone()),
            container_path: container_path.into(),
        }
    }
}

impl WriteConfig for Mount {
    fn write_to(&self, writer: &mut IndentedWriter) {
        let host = match &self.host_path {
            VolumeOrPath::Volume(volume) => volume.name.to_string(),
            VolumeOrPath::Path(path) => path.to_string_lossy().to_string(),
        };

        let container = self.container_path.to_string_lossy().to_string();

        writeln!(writer, "- {host}:{container}").expect("writing to a string doesn't fail")
    }
}

impl Volume {
    /// Private: callers can only obtain an `Arc<Volume>`, via
    /// [`ComposeConfig::add_volume`].
    fn new(name: String) -> Self {
        Self { name }
    }

    /// Get the name of the volume.
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Get the path corresponding to a root directory named after the volume.
    ///
    /// ```
    /// use swap_orchestrator::compose2::*;
    /// use std::path::PathBuf;
    ///
    /// let mut config = ComposeConfig::default();
    /// let my_volume = config.add_volume("foo");
    /// assert_eq!(my_volume.as_root_dir(), PathBuf::from("/foo/"));
    /// ```
    pub fn as_root_dir(&self) -> PathBuf {
        let mut path = PathBuf::from("/");
        path.push(&self.name);

        path
    }
}

impl WriteConfig for Volume {
    fn write_to(&self, writer: &mut IndentedWriter) {
        writeln!(writer, "{}:", &self.name).unwrap()
    }
}

impl WriteConfig for RestartType {
    fn write_to(&self, writer: &mut IndentedWriter) {
        let text = match self {
            RestartType::UnlessStopped => "unless-stopped",
        };
        writeln!(writer, "restart: {text}").unwrap();
    }
}

impl Command {
    /// Create a new command by combining flags.
    pub fn new(flags: impl IntoIterator<Item = Flag>) -> Command {
        Command {
            flags: flags.into_iter().collect(),
        }
    }

    /// Add a flag dynamically.
    pub fn add_flag(&mut self, flag: impl Into<Flag>) {
        self.flags.push(flag.into());
    }
}

impl WriteConfig for Command {
    fn write_to(&self, writer: &mut IndentedWriter) {
        let flags = self
            .flags
            .iter()
            .map(|flag| format!("{flag}"))
            .collect::<Vec<_>>()
            .join(", ");
        writeln!(writer, "command: [ {flags} ]").unwrap();
    }
}

#[macro_export]
macro_rules! flag {
    ($flag:expr) => {
        crate::compose::Flag::new(format!($flag))
    };
    ($flag:expr, $($args:expr),*) => {
        crate::compose::Flag::new(format!($flag, $($args),*))
    };
}

#[macro_export]
macro_rules! command {
    ($command:expr $(, $flag:expr)* $(,)?) => {
        crate::compose::Command::new(vec![flag!($command) $(, $flag)*])
    };
}

impl Flag {
    pub fn new(value: impl Into<String>) -> Flag {
        Flag(value.into())
    }
}

impl Display for Flag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "\"{}\"", self.0)
    }
}

impl From<String> for Flag {
    fn from(value: String) -> Self {
        Flag::new(value)
    }
}

impl IntoIterator for Flag {
    type Item = Flag;
    type IntoIter = <Vec<Flag> as IntoIterator>::IntoIter;

    fn into_iter(self) -> Self::IntoIter {
        vec![self].into_iter()
    }
}
