use bitcoin_wallet::rpc::RpcHandler as BtcHandler;
use monero_wallet::rpc::RpcHandler as XmrHandler;

fn main() {
    println!("// This file is auto-generated by the Rust build system.");
    println!("// Do not edit manually.\n");

    println!("export type BitcoinRpc = {{");
    for handler in inventory::iter::<BtcHandler> {
        print_function(handler.name, handler.args, handler.return_type);
    }
    println!("}}\n");

    println!("export type MoneroRpc = {{");
    for handler in inventory::iter::<XmrHandler> {
        print_function(handler.name, handler.args, handler.return_type);
    }
    println!("}}");
}

fn print_function(name: &str, args: &str, ret: &str) {
    let ts_ret = map_rust_type_to_ts(ret);
    let arg_parts: Vec<&str> = args.split(',').collect();
    
    let mut ts_args_list = Vec::new();
    let mut amount_count = 0;
    let mut key_count = 0;

    for part in arg_parts {
        let clean_part = part.trim();
        
        // FILTERING LOGIC:
        // 1. Skip Wallet structs
        // 2. Skip artifacts of generic splitting (e.g. "StaticFeeRate >")
        if clean_part.contains("Wallet") || clean_part.contains("self") || clean_part.contains(">") || clean_part.contains("StaticFeeRate") {
            continue;
        }

        let ts_type = map_rust_type_to_ts(clean_part);
        
        // NAMING LOGIC:
        let var_name = if clean_part.contains("Address") {
            "address".to_string()
        } else if clean_part.contains("Amount") {
            amount_count += 1;
            if amount_count > 1 { format!("amount_{}", amount_count) } else { "amount".to_string() }
        } else if clean_part.contains("TxHash") {
            "tx_hash".to_string()
        } else if clean_part.contains("Key") {
            key_count += 1;
            if key_count > 1 { format!("key_{}", key_count) } else { "key".to_string() }
        } else {
            "arg".to_string()
        };

        if !var_name.is_empty() {
             ts_args_list.push(format!("{}: {}", var_name, ts_type));
        }
    }

    let final_args = ts_args_list.join(", ");
    println!("  {}: ({}) => Promise<{}>;", name, final_args, ts_ret);
}

fn map_rust_type_to_ts(rust_type: &str) -> String {
    if rust_type.contains("Psbt") { return "string".to_string(); }
    if rust_type.contains("Address") { return "string".to_string(); }
    if rust_type.contains("TxHash") { return "string".to_string(); }
    if rust_type.contains("Key") { return "string".to_string(); } // Keys are usually hex strings in JS
    if rust_type.contains("Amount") { return "number".to_string(); }
    if rust_type.contains("bool") { return "boolean".to_string(); }
    if rust_type.contains("u64") { return "number".to_string(); }
    if rust_type.contains("u32") { return "number".to_string(); }
    if rust_type.contains("String") { return "string".to_string(); }
    
    "any".to_string()
}
