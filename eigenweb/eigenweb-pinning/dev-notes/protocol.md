### What are we solving?

### Parties

- Alice: Wants to send the message `msg` to Bob (client)
- Bob: Wants to receive a message from Alice (client)
- Clara: Is running a pinning server which stores messages (server)
- David: Is also running a pinning server (server)

We call the pinned message `msg`.

### Permissioned pinning

If Alice wants to pin a message for Bob, she must provide a signed message from Bob which says:
xw

> I am Bob. I allow Alice to pin messages for me totalling at most 100kb. This expires on July 1st, 2026.

Alice attaches that signed message (`msg.slip`) when asking Clara to pin her message. Clara keeps track of the signed messages.

These messages are additive meaning that if Bob signs multiple 3 messages saying:

> I am Bob. I allow Alice to pin messages for me totalling at most 100kb. This expires on July 1st, 2026.

Then Clara will accept up to 300kb of messages from Alice for Bob.

**For simplicity, this is not implemented and won't be for a while: For now this is not implemented.**

### Unpermissioned pinning

Clara can chose to also allow Alice to pin without a signed message as this is a local decision. She might risks spam by doing this. Although PeerIDs can easily be faked and are not an identication of any one person.

The signed messages are a protection for Bob, he can say:

> I am Bob. Clara please give me all messages from Alice but only those that I have allowed.

If Bob is not worried about spam from Alice, he can say:

> I am bob. Clara please give me all messages from Alice.

This might be useful in a transitionary period. If Alice wants to pin something for Bob (for example a cooperative redeem key) but she did the swap with Alice before message pinning was introduced.

Our initial implementation will therefore default to unpermissioned pinning.

### Time to live

Some messages are useful only useful for a specific period of time. Some should be stored for as long as possible.

All messages are required to have a `msg.ttl` embedded in them which is represented as a UNIX timestamp.

Clara can track when she received a message for the first time. She can then decide to still prune messages after a locally defined `max_ttl` has passed.

### Signatures

All messages have exactly one sender (`msg.sender`) and one receiver (`msg.receiver`). They are of type `PeerId`.

As opposed to how the rendezvous protocol works, the message does not need to be signed specifically for Clara. This means Clara can choose to share `msg` with David. Bob can then retrieve `msg` from David.

Clara and David could run a gossipsub protocol to share messages with each other.

### Grants

Clara only has `x` bytes of storage. If she wants to continue to accept messages, she needs to prune old messages.

- She can do this based on the `msg.ttl` and the `local_consensus.max_ttl` she has set but that might not be enough.
- She could choose to allow a certain amount of messages for each peer but peers are simple to fake.

She therefore needs a way to prioritize messages from certain peers. We do this by introducing the concept of a `grant`.

A `grant` can be generated by peer by doing some amount of work that is expensive but can be easily verified. There are two contenders for this:

1. Proof of work
2. Financial incentives

We choose to ditch proof of work now and focus on financial incentives.

Alice can generate a `grant` by donating some amount of Monero (XMR) to a set of accepted donation addresses. These are not ensured to be globally shared but Clara can herself decide which addresses she wants to accept. In practice this might be the donation address of the [Monero General Fund](https://www.getmonero.org/get-started/contributing/) or a non-profit such as [Anti War](https://www.antiwar.com/cryptocurrencies/).

```rust
Grant {
    peer_id: PeerId,
    grant_id: Uuid,
    transfer_proof: TransferProof,
}
```

Alice will then donate some amount of Monero (e.g `0.1 XMR`) to one of the addresses she thinks Clara will accept. Alice then constructs a [transfer proof](https://www.getmonero.org/resources/user-guides/prove-payment.html) and attaches it to the message she sends Clara.

Under the hood, constructing a transfer proof calls a function like `getTxProof(txid, address, proof_message)` in the Monero library. Alice sets `proof_message = "grant_<grant_id>_<peer_id_base58>"`. This ensures the transfer proof was actually generated by Alice and she did not use a transfer proof from another peer.

Clara stores all `grants` she has receives. She will accept them for `local_consensus.grant_ttl_blocks` Monero blocks. After that she will discard them and deem them invalid.

Clara now has the ability to prioritize messages from certain peers. She could for example choose to split her `100mb` of storage proportionally between all peers who have sent her a `grant` and prioritize messages from them.

Grants are not tied to specific messages. They are a way to allocate limited storage to a possibly unlimited number of messages.
Grants can safely be gossiped between servers as they are expensive to generate.

**For simplicity, this is not implemented and won't be for a while: For now this is not implemented.**

### Prioritization

Alice might sends a lot of messages to Clara. She knows that Clara will only accept so many messages from her. Clara will prioritize messages based on the `msg.priority` field. In case of a tie, she will prioritize messages based on the `msg.ttl` field (discard messages with a smaller `msg.ttl`).

Alice might choose to initially set `msg.priority` to `0`. She could also set `msg.priority` to the current UNIX timestamp. In this case Clara will prioritize newer messages over older messages.

If there are important messages, Alice can set `msg.priority` to `U64::MAX` to maximize the chances of them being stored for a longer period of time.

## Protocol

First Alice sends a `PinRequest` to Clara. Clara will then respond with a `PinResponse`.

```rust
/// Alice sends this to Clara asking her to pin the message
struct PinRequest {
    signed_msg: SignedPinnedMessage,
}
```

```rust
enum PinResponse {
    Stored,
    Rejected(PinRejectReason),
}

enum PinRejectReason {
    /// Alice does not accept any more messages
    ResourceLimitExceeded,
    MalformedMessage,
}
```

```rust
SignedPinnedMessage {
    message: UnsignedPinnedMessage,
    key: PublicKey,
    signature: Vec<u8>,
}
```

```rust
UnsignedPinnedMessage {
    id: Uuid,
    sender: PeerId,
    receiver: PeerId,
    ttl: u64,
    priority: u64,
    encrypted_content: Bytes,
}
```

```rust
PullRequest {
    /// These are the IDs of messages we already have
    exclude: Vec<Uuid>,
}
```

```rust
PullResponse {
    messages: Vec<SignedPinnedMessage>,
}
```

## Future additions. Do not implement these yet!

```rust
/// 
/// Tells the rest of the network that the `receiver` is willing to accept messages from `sender`
/// 
/// Becomes invalid after `ttl` (UNIX timestamp)
/// 
/// `size_limit` is the limit for the total size of all the messages
/// `count_limit` is the limit for the number of messages
/// 
/// Permissions are additive the `size_limit` and `count_limit` should be summed
UnsignedPermission {
    permission_id: Uuid,
    /// The peer that is allowing messages to be sent to her
    /// This is the `receiver` of the message
    receiver: PeerId,
    /// The peer that is allowed to send messages to the receiver
    sender: PeerId,
    ttl: u64,
    size_limit: u64,
    count_limit: u64,
}
```
